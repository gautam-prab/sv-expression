# make_violin_plot.py
# Make violin plots of SV/gene pairs found by process_rnaseq.py

import argparse
from cyvcf2 import VCF
import pickle
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

def build_args():
    parser = argparse.ArgumentParser(description='Make violin plots of SV/gene pairs found by process_rnaseq.py')
    parser.add_argument('--rnafile', default='Data/GD462.GeneQuantRPKM.50FN.samplename.resk10.txt')
    parser.add_argument('--vcffile', default='allSVs.vcf.gz')
    parser.add_argument('--exonfile', default='exons.csv', help='Generated by determine_coding_vs_noncoding.py') # generated by determine_coding_vs_noncoding.py
    parser.add_argument('--type_separation', default='sv', help='Separate by SV Type or Gene Type (enter \"sv\" or \"gene\")')
    parser.add_argument('--exonic', const=True, default=False, nargs='?', help='Include tag if you want separate plots for coding & noncoding')
    return parser.parse_args()

def get_samples(args):
    df = pd.read_csv(args.rnafile, sep='\t', index_col=0)
    pop_df = pd.read_csv('Data/integrated_call_samples_v3.20130502.ALL.panel', sep='\t', index_col=0)
    geuvadis_samples = df.iloc[:,3:].keys().values
    svs_samples = pop_df.index.values
    samples = np.intersect1d(geuvadis_samples, svs_samples)
    return samples

# for use on CNVs
def resolve_alts(gt, alts, alt_dict):
    ret = 0
    if int(gt[0]) != 0: # not reference allele
        alt = alts[int(gt[0]) - 1]
        ret += alt_dict[alt]
    else: # reference allele is copy number 1
        ret += 1
    if int(gt[1]) != 0: # not reference allele
        alt = alts[int(gt[1]) - 1]
        ret += alt_dict[alt]
    else:
        ret += 1
    return ret

def find_beta(record, df, keep_samples, sample_order, verbose=True):
    alt_dict = {'<CN0>' : 0, '<CN2>' : 2, '<CN3>' : 3, '<CN4>' : 4, '<CN5>' : 5, '<CN6>' : 6, '<CN7>' : 7, '<CN8>' : 8, '<CN9>' : 9}

    gene = record.INFO.get('gene')
    dat = df.loc[gene]
    dat = (dat - dat.mean()) / dat.std()

    x = np.zeros(len(dat))
    y = np.zeros(len(dat))

    i = 0
    alts = record.ALT
    for sample in keep_samples:
        idx = sample_order.index(sample)
        gt = record.genotypes[idx]
        if record.INFO.get('SVTYPE') == 'CNV' and alts[0] in alt_dict:
            val = resolve_alts(gt, alts, alt_dict)
        else:
            val = min(int(gt[0]),1) + min(int(gt[1]),1)
        x[i] = val
        y[i] = dat[sample]
        i += 1

    model = LinearRegression()
    model.fit(x.reshape(-1, 1), y.reshape(-1, 1))

    print('{} with {} has beta of {}'.format(gene, record.ID, model.coef_[0][0]))

    return model.coef_[0][0]

def make_violin_plot(args, dict, title):
    fig, ax = plt.subplots()

    labels = dict.keys()
    ax.get_xaxis().set_tick_params(direction='out')
    ax.xaxis.set_ticks_position('bottom')
    ax.set_xticks(np.arange(1, len(labels) + 1))
    ax.set_xlim(0.25, len(labels) + 0.75)
    if args.type_separation == 'sv':
        ax.set_xticklabels(labels)
        ax.set_xlabel('SV Type')
    elif args.type_separation == 'gene':
        ax.set_xlabel('Gene Type')
        ax.set_xticklabels(labels, fontsize=8)
        plt.xticks(rotation=90)

    ax.set_ylabel('Effect Size (beta)')
    [bottom, top] = ax.get_ylim()
    ax.set_ylim(min(bottom, -1), max(top, 1))
    ax.set_title(title)

    ax.violinplot([dict[key] for key in dict.keys()])

    i = 1
    max_beta = 0
    for key in dict.keys():
        samp_count = len(dict[key])
        ax.text(x=i,y=0.97,s=samp_count,fontsize=8,color='gray', horizontalalignment='center', transform=ax.get_xaxis_transform())
        i+=1

    plt.show()

def main():
    args = build_args()

    keep_samples = get_samples(args)
    qtls = VCF(args.vcffile, samples=keep_samples.tolist())
    sample_order = qtls.samples

    df = pd.read_csv(args.rnafile, sep='\t', index_col=0)
    df = df[keep_samples]

    if args.type_separation == 'gene':
        exon_df = pd.read_csv(args.exonfile, sep=',', index_col=0)

    if args.exonic:
        ex_dict = {}
        nonex_dict = {}
        for record in qtls:
            gene = record.INFO.get('gene')
            if args.type_separation == 'sv':
                type = record.INFO.get('SVTYPE')
            elif args.type_separation == 'gene':
                type = exon_df.loc[gene.split('.')[0], 'ensembl.type_of_gene']
            else:
                print('Error')
                break
            ex = record.INFO.get('exonic')

            if ex == 'y':
                if type not in ex_dict:
                    ex_dict[type] = []
                ex_dict[type].append(find_beta(record, df, keep_samples, sample_order))

            elif ex == 'n':
                if type not in nonex_dict:
                    nonex_dict[type] = []
                nonex_dict[type].append(find_beta(record, df, keep_samples, sample_order))
        make_violin_plot(args, ex_dict, 'Effect Sizes of Coding SV-Gene Pairs')
        make_violin_plot(args, nonex_dict, 'Effect Sizes of Noncoding SV-Gene Pairs')

    else:
        dict = {}
        for record in qtls:
            gene = record.INFO.get('gene')
            if args.type_separation == 'sv':
                type = record.INFO.get('SVTYPE')
            elif args.type_separation == 'gene':
                type = exon_df.loc[gene.split('.')[0], 'ensembl.type_of_gene']
            else:
                print('Error')
                break

            if type not in dict:
                dict[type] = []

            dict[type].append(find_beta(record, df, keep_samples, sample_order))
        make_violin_plot(args, dict, 'Effect Sizes of SV-Gene Pairs')

if __name__ == '__main__':
    main()
